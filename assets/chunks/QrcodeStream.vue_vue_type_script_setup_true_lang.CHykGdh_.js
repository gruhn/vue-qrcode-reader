import{d as X,h as i,y as u,j as Y,A as Z,g as _,c as ee,o as te,k as g,a4 as ae,O as oe,a7 as ne,r as se}from"./framework.BZTtPEZj.js";import{s as p,b as o,c as ie,d as re,k as le}from"./camera.G18_pu39.js";const ue=X({__name:"QrcodeStream",props:{constraints:{default:()=>({facingMode:"environment"})},formats:{default:()=>["qr_code"]},paused:{type:Boolean,default:!1},torch:{type:Boolean,default:!1},track:{type:Function,default:void 0}},emits:["detect","camera-on","camera-off","error"],setup(J,{emit:j}){const n=J,h=j,M=i(n.constraints),w=i(n.formats);u(()=>n.constraints,(t,e)=>{JSON.stringify(t)!==JSON.stringify(e)&&(M.value=t)},{deep:!0}),u(()=>n.formats,(t,e)=>{JSON.stringify(t)!==JSON.stringify(e)&&(w.value=t)},{deep:!0});const f=i(),v=i(),c=i(),m=i(!1),y=i(!1);Y(()=>{y.value=!0}),Z(()=>{p()});const O=_(()=>({torch:n.torch,constraints:M.value,shouldStream:y.value&&!n.paused}));u(O,async t=>{const e=c.value;o(e!==void 0,"cameraSettings watcher should never be triggered when component is not mounted. Thus video element should always be defined.");const a=f.value;o(a!==void 0,"cameraSettings watcher should never be triggered when component is not mounted. Thus canvas should always be defined.");const d=a.getContext("2d");if(o(d!==null,"if cavnas is defined, canvas 2d context should also be non-null"),t.shouldStream){p(),m.value=!1;try{const r=await ie(e,t);y.value?(m.value=!0,h("camera-on",r)):await p()}catch(r){h("error",r)}}else a.width=e.videoWidth,a.height=e.videoHeight,d.drawImage(e,0,0,e.videoWidth,e.videoHeight),p(),m.value=!1,h("camera-off")},{deep:!0}),u(w,t=>{y.value&&re(t)});const S=_(()=>O.value.shouldStream&&m.value);u(S,t=>{if(t){o(f.value!==void 0,"shouldScan watcher should only be triggered when component is mounted. Thus pause frame canvas is defined"),x(f.value),o(v.value!==void 0,"shouldScan watcher should only be triggered when component is mounted. Thus tracking canvas is defined"),x(v.value);const e=()=>n.track===void 0?500:40;o(c.value!==void 0,"shouldScan watcher should only be triggered when component is mounted. Thus video element is defined"),le(c.value,{detectHandler:a=>h("detect",a),formats:w.value,locateHandler:q,minDelay:e()})}});const x=t=>{const e=t.getContext("2d");o(e!==null,"canvas 2d context should always be non-null"),e.clearRect(0,0,t.width,t.height)},q=t=>{const e=v.value;o(e!==void 0,"onLocate handler should only be called when component is mounted. Thus tracking canvas is always defined.");const a=c.value;if(o(a!==void 0,"onLocate handler should only be called when component is mounted. Thus video element is always defined."),t.length===0||n.track===void 0)x(e);else{const d=a.offsetWidth,r=a.offsetHeight,k=a.videoWidth,R=a.videoHeight,B=Math.max(d/k,r/R),T=k*B,C=R*B,F=T/k,z=C/R,A=(d-T)/2,I=(r-C)/2,H=({x:l,y:s})=>({x:Math.floor(l*F),y:Math.floor(s*z)}),L=({x:l,y:s})=>({x:Math.floor(l+A),y:Math.floor(s+I)}),P=t.map(l=>{const{boundingBox:s,cornerPoints:Q}=l,{x:U,y:V}=L(H({x:s.x,y:s.y})),{x:$,y:G}=H({x:s.width,y:s.height});return{...l,cornerPoints:Q.map(K=>L(H(K))),boundingBox:DOMRectReadOnly.fromRect({x:U,y:V,width:$,height:G})}});e.width=a.offsetWidth,e.height=a.offsetHeight;const N=e.getContext("2d");o(N!==null,"canvas 2d context should always be non-null"),n.track(P,N)}},D={width:"100%",height:"100%",position:"relative","z-index":"0"},W={width:"100%",height:"100%",position:"absolute",top:"0",left:"0"},b={width:"100%",height:"100%","object-fit":"cover"},E=_(()=>S.value?b:{...b,visibility:"hidden",position:"absolute"});return(t,e)=>(te(),ee("div",{style:D},[g("video",{ref_key:"videoRef",ref:c,style:oe(E.value),autoplay:"",muted:"",playsinline:""},null,4),ae(g("canvas",{id:"qrcode-stream-pause-frame",ref_key:"pauseFrameRef",ref:f,style:b},null,512),[[ne,!S.value]]),g("canvas",{id:"qrcode-stream-tracking-layer",ref_key:"trackingLayerRef",ref:v,style:W},null,512),g("div",{style:W},[se(t.$slots,"default")])]))}});export{ue as _};
